

 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
    
    
    
    
    <title>《go语言编程》☞鉴赏 | Yison's Blog</title>


    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="yison">
    

    
    <!--<%- open_graph({twitter_id: theme.author.twitter, google_plus: theme.author.google_plus}) %>-->

    <meta name="description" content="page.description">
    
    <meta property="og:type" content="article">
    
    <meta property="og:title" content="《go语言编程》☞鉴赏">
    <meta property="og:url" content="/%E8%AF%BB%E4%B9%A6/%E7%BC%96%E7%A8%8B/2020/12/03/Go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B-%E9%89%B4%E8%B5%8F/">
    <meta property="og:site_name" content="Yison's Blog">
    <meta property="og:description" content="">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="《go语言编程》☞鉴赏">
    <meta name="twitter:description" content="page.description">
    <meta name="twitter:creator" content="@">
    <link rel="publisher" href="">

    
    <link rel="alternative" href="/atom.xml" title="Yison's Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/assets/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/assets/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/assets/img/jacman.jpg">
    

    <link rel="stylesheet" href="/assets/css/style.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/highlight.css" type="text/css">
    
    
</head>

  <body>
    <header>
        <div>
		    
			<div id="imglogo">
				<a href="/"><img src="/assets/img/logo.png" alt="Yison's Blog" title="Yison's Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Yison's Blog">Yison's Blog</a></h1>
				<h2 class="blog-motto">Do one thing at a time, and do well.</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="/search" method="get" accept-charset="utf-8">
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
					</form>
					
					</li>
				</ul>
			</nav>
</div>

    </header>
    <div id="container">
      



<div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
	<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/%E8%AF%BB%E4%B9%A6/%E7%BC%96%E7%A8%8B/2020/12/03/Go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B-%E9%89%B4%E8%B5%8F/" title="《go语言编程》☞鉴赏" itemprop="url">《go语言编程》☞鉴赏</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="yison" target="_blank" itemprop="author">yison</a>
		
  <p class="article-time">
    <time datetime="2020-12-03 00:00:00 +0800" itemprop="datePublished"> 发表于 2020-12-03</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article toc-content" style="display: none;">
		
			<!--<%- toc(item.content) %>-->
		
		</div>
		
		<blockquote>
  <p>在读这本书之前，我已经熟悉了Go的语法，并编码实现了具体的应用。但这本书据说详细解读了Go语言的诞生背景和作者的设计初衷&amp;理念，所以，带着好奇的心态读了这本书，顺带查缺补漏。</p>
</blockquote>

<h2 id="前言">前言</h2>
<p>Go语言官方自称，之所以开发Go 语言，是因为“近10年来开发程序之难让我们有点沮丧”。<br />
这一定位暗示了Go语言希望取代C和Java的地位，成为最流行的通用开发语言。</p>

<p>Go希望成为互联网时代的C语言。多数系统级语言（包括Java和C#）的根本编程哲学来源于C++，将C++的面向对象进一步发扬光大。但是Go语言的设计者却有不同的看法，他们认为C++ 真的没啥好学的，值得学习的是C语言。</p>

<p>C语言经久不衰的根源是它足够简单。因此，Go语言也要足够简单！</p>

<p><img src="/assets/img/article/2020-12-03/toibe_rank.jpeg" alt="" /></p>

<blockquote>
  <p>如果一个特性
并不对解决任何问题有显著的价值，那么Go就不提供它</p>
</blockquote>

<h3 id="并发与分布式">并发与分布式</h3>
<p>多核化和集群化是互联网时代的典型特征，那语言需要哪些特性来应对这些特征呢？</p>

<p><strong>并发执行的“执行体”</strong><br />
执行体是个抽象的概念，在操作系统层面有多个概念与之对应，比如操作系统自己掌管的进程（process）、进程内的线程（thread）以及进程内的协程（coroutine，也叫轻量级线程）。</p>

<p>多数语言在语法层面并不直接支持协程，而通过库的方式支持的协程的功能也并不完整，比如仅仅提供协程的创建、销毁与切换等能力。如果在这样的协程中调用一个同步IO操作，比如网络通信、本地文件读写，都会阻塞其他的并发执行协程，从而无法真正达到协程本身期望达到的目标。</p>

<p>Go语言在语言级别支持协程，叫goroutine。Go语言标准库提供的所有系统调用（syscall）操
作，当然也包括所有同步IO操作，都会出让CPU给其他goroutine，这让事情变得非常简单。我们
对比一下Java和Go，近距离观摩下两者对“执行体”的支持。</p>

<p>为了简化，我们在样例中使用的是Java标准库中的线程，而不是协程，具体代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span> 
 	<span class="n">String</span> <span class="n">arg</span><span class="o">;</span> 
	<span class="kd">public</span> <span class="nf">MyThread</span><span class="o">(</span><span class="n">String</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span> 
 		<span class="n">arg</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span> 
 	<span class="o">}</span> 
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> 
 		<span class="c1">// ... </span>
 	<span class="o">}</span> 
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span> 
		<span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">MyThread</span><span class="o">(</span><span class="s">"test"</span><span class="o">)).</span><span class="na">start</span><span class="o">();</span> 
 		<span class="c1">// ... </span>
 	<span class="o">}</span>
<span class="o">}</span> 
</code></pre></div></div>

<p>相同功能的代码，在Go语言中是这样的：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">run</span><span class="p">(</span><span class="n">arg</span><span class="x"> </span><span class="kt">string</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x"> 
 	</span><span class="c">// ... </span><span class="x">
</span><span class="p">}</span><span class="x"> 
</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x"> 
	</span><span class="k">go</span><span class="x"> </span><span class="n">run</span><span class="p">(</span><span class="s">"test"</span><span class="p">)</span><span class="x"> 
 	</span><span class="o">...</span><span class="x"> 
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>对比非常鲜明。我相信你已经明白为什么Go语言会叫Go语言了：Go语言献给这个时代最好
的礼物，就是加了go这个关键字。</p>

<p><strong>“执行体间的通信”</strong><br />
执行体间的通信包含几个方式：</p>

<ul>
  <li>执行体之间的互斥与同步
    <ul>
      <li>当执行体之间存在共享资源（一般是共享内存）时，为保证内存访问逻辑的确定性，需要对访问该共享资源的相关执行体进行互斥。当多个执行体之间的逻辑存在时序上的依赖时，也往往需要在执行体之间进行同步。</li>
      <li>互斥与同步是执行体间最基础的交互方式。</li>
      <li>多数语言在库层面提供了线程间的互斥与同步支持，那么协程之间的互斥与同步呢？
        <ul>
          <li>呃，不好意思，没有。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>执行体之间的消息传递
    <ul>
      <li>在并发编程模型的选择上，有两个流派，一个是共享内存模型，一个是消息传递模型。</li>
      <li>多数传统语言选择了前者，少数语言选择后者，其中选择“消息传递模型”的最典型代表是Erlang语言。业界有专门的术语叫“Erlang风格的并发模型”，其主体思想是两点：一是“轻量级的进程（Erlang中‘进程’这个术语就是我们上面说的‘执行体’）”，二是“消息乃进程间通信的唯一方式”。</li>
      <li>Go语言推荐采用“Erlang风格的并发模型”的编程范式，尽管传统的“共享内存模型”仍然被保留，允许适度地使用。在Go语言中内置了消息队列的支持，只不过它叫通道（channel）。两
个goroutine之间可以通过通道来进行交互。</li>
    </ul>
  </li>
</ul>

<h3 id="软件工程">软件工程</h3>
<p>单机时代的语言可以只关心问题本身的解决，但是随着工程规模的不断扩大，软件复杂度的
不断增加，软件工程也成为语言设计层面要考虑的重要课题。</p>

<p>多数软件需要一个团队共同去完成，在团队协作的过程中，人们需要建立统一的交互语言来降低沟通的成本。规范化体现在多个层面，如：</p>

<ul>
  <li>代码风格规范</li>
  <li>错误处理规范</li>
  <li>包管理</li>
  <li>契约规范（接口）</li>
  <li>单元测试规范</li>
  <li>功能开发的流程规范</li>
</ul>

<p>Go语言很可能是第一个将代码风格强制统一的语言，例如Go语言要求public的变量必须以
大写字母开头，private变量则以小写字母开头，这种做法不仅免除了public、private关键
字，更重要的是统一了命名风格。</p>

<p>另外，Go语言对{ }应该怎么写进行了强制，比如以下风格是正确的：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="x"> </span><span class="n">expression</span><span class="x"> </span><span class="p">{</span><span class="x"> 
 </span><span class="o">...</span><span class="x"> 
</span><span class="p">}</span><span class="x"> 
</span></code></pre></div></div>
<p>但下面这个写法就是错误的：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="x"> </span><span class="n">expression</span><span class="x"> 
</span><span class="p">{</span><span class="x"> 
 </span><span class="o">...</span><span class="x"> 
</span><span class="p">}</span><span class="x"> 
</span></code></pre></div></div>

<p>而C和Java语言中则对花括号的位置没有任何要求。哪种更有利，这个见仁见智。但很显然
的是，所有的Go代码的花括号位置肯定是非常统一的。</p>

<p>最有意思的其实还是 Go 语言首创的错误处理规范：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="x"> 
</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x"> 
 	</span><span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Open file failed:"</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="p">)</span><span class="x"> 
 	</span><span class="k">return</span><span class="x"> 
</span><span class="p">}</span><span class="x"> 
</span><span class="k">defer</span><span class="x"> </span><span class="n">f</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span><span class="x"> 
</span><span class="o">...</span><span class="x"> </span><span class="c">// 操作已经打开的f文件</span><span class="x">
</span></code></pre></div></div>

<blockquote>
  <p>defer语句的含义是不管程序是否出现异常，均在函数退出时自动执行相关代码。<br />
Go语言的函数允许返回多个值。</p>
</blockquote>

<p>大多数函数的最后一个返回值会为error类型，以在错误情况下返回详细信息。<br />
error类型只是一个系统内置的interface，如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{</span><span class="x"> 
 	</span><span class="n">Error</span><span class="p">()</span><span class="x"> </span><span class="kt">string</span><span class="x">
</span><span class="p">}</span><span class="x"> 
</span></code></pre></div></div>
<p>有了error类型，程序出现错误的逻辑看起来就相当统一。</p>

<p>在Java中，你可能这样写代码来保证资源正确释放：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span> 
 	<span class="n">Statement</span> <span class="n">stmt</span> <span class="o">=</span> <span class="o">...;</span> 
	<span class="k">try</span> <span class="o">{</span> 
 		<span class="n">ResultSet</span> <span class="n">rset</span> <span class="o">=</span> <span class="o">...;</span> 
		<span class="k">try</span> <span class="o">{</span> 
 			<span class="o">...</span> <span class="c1">// 正常代码</span>
 		<span class="o">}</span> 
		<span class="k">finally</span> <span class="o">{</span> 
 			<span class="n">rset</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> 
 		<span class="o">}</span> 
 	<span class="o">}</span> 
	<span class="k">finally</span> <span class="o">{</span> 
 		<span class="n">stmt</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> 
 	<span class="o">}</span> 
<span class="o">}</span> 
<span class="k">finally</span> <span class="o">{</span> 
<span class="n">conn</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> 
<span class="o">}</span> 
</code></pre></div></div>
<p>完成同样的功能，相应的Go代码只需要写成这样：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">conn</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="o">...</span><span class="x"> 
</span><span class="k">defer</span><span class="x"> </span><span class="n">conn</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span><span class="x"> 
</span><span class="n">stmt</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="o">...</span><span class="x"> 
</span><span class="k">defer</span><span class="x"> </span><span class="n">stmt</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span><span class="x"> 
</span><span class="n">rset</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="o">...</span><span class="x"> 
</span><span class="k">defer</span><span class="x"> </span><span class="n">rset</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span><span class="x"> 
</span><span class="o">...</span><span class="x"> </span><span class="c">// 正常代码</span><span class="x">
</span></code></pre></div></div>
<p>对比两段代码，Go语言处理错误的优势显而易见。当然，其实Go语言带给我们的惊喜还有很多。</p>

<h3 id="编程哲学">编程哲学</h3>
<p>计算机软件经历了数十年的发展，形成了多种学术流派，有面向过程编程、面向对象编程、
函数式编程、面向消息编程等，这些思想究竟孰优孰劣，众说纷纭。
C语言是纯过程式的，这和它产生的历史背景有关。Java语言则是激进的面向对象主义推崇
者，典型表现是它不能容忍体系里存在孤立的函数。而Go语言没有去否认任何一方，而是用批
判吸收的眼光，将所有编程思想做了一次梳理，融合众家之长，但时刻警惕特性复杂化，极力维
持语言特性的简洁，力求小而精。
从编程范式的角度来说，Go语言是变革派，而不是改良派。
对于C++、Java和C#等语言为代表的面向对象（OO）思想体系，Go语言总体来说持保守态
度，有限吸收。
首先，Go语言反对函数和操作符重载（overload），而C++、Java和C#都允许出现同名函数或
操作符，只要它们的参数列表不同。虽然重载解决了一小部分面向对象编程（OOP）的问题，但
同样给这些语言带来了极大的负担。而Go语言有着完全不同的设计哲学，既然函数重载带来了
负担，并且这个特性并不对解决任何问题有显著的价值，那么Go就不提供它。
其次，Go语言支持类、类成员方法、类的组合，但反对继承，反对虚函数（virtual function）
和虚函数重载。确切地说，Go也提供了继承，只不过是采用了组合的文法来提供：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Foo struct { 
 	Base 
 	... 
} 
func (foo *Foo) Bar() { 
 	... 
} 
</code></pre></div></div>
<p>再次，Go语言也放弃了构造函数（constructor）和析构函数（destructor）。由于Go语言中没
有虚函数，也就没有vptr，支持构造函数和析构函数就没有太大的价值。本着“如果一个特性
并不对解决任何问题有显著的价值，那么Go就不提供它”的原则，构造函数和析构函数就这样
被Go语言的作者们干掉了。
在放弃了大量的OOP特性后，Go语言送上了一份非常棒的礼物：接口（interface）。你可能
会说，除了C这么原始的语言外，还有什么语言没有接口呢？是的，多数语言都提供接口，但它
们的接口都不同于Go语言的接口。
Go语言中的接口与其他语言最大的一点区别是它的非侵入性。在C++、Java和C#中，为了实
现一个接口，你需要从该接口继承，具体代码如下：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Foo implements IFoo { // Java文法
 	... 
} 
class Foo : public IFoo { // C++文法
 	... 
} 
IFoo* foo = new Foo; 
在Go语言中，实现类的时候无需从接口派生，具体代码如下：
type Foo struct { // Go 文法
 	... 
} 
var foo IFoo = new(Foo) 
</code></pre></div></div>
<p>只要Foo实现了接口IFoo要求的所有方法，就实现了该接口，可以进行赋值。
Go语言的非侵入式接口，看似只是做了很小的文法调整，实则影响深远。
其一，Go语言的标准库再也不需要绘制类库的继承树图。你只需要知道这个类实现了哪些
方法，每个方法是啥含义就足够了。
其二，不用再纠结接口需要拆得多细才合理，比如我们实现了File类，它有下面这些方法：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Read(buf []byte) (n int, err error) 
Write(buf []byte) (n int, err error) 
Seek(off int64, whence int) (pos int64, err error) 
Close() error 
</code></pre></div></div>
<p>那么，到底是应该定义一个IFile接口，还是应该定义一系列的IReader、IWriter、
ISeeker和ICloser接口，然后让File从它们派生好呢？事实上，脱离了实际的用户场景，讨
论这两个设计哪个更好并无意义。问题在于，实现File类的时候，我怎么知道外部会如何用它
呢？
其三，不用为了实现一个接口而专门导入一个包，而目的仅仅是引用其中的某个接口的定义。
在Go语言中，只要两个接口拥有相同的方法列表，那么它们就是等同的，可以相互赋值，如对
于以下两个接口，第一个接口：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">one</span> 
<span class="n">type</span> <span class="n">ReadWriter</span> <span class="n">interface</span> <span class="p">{</span> 
 	<span class="n">Read</span><span class="p">(</span><span class="n">buf</span> <span class="p">[]</span> <span class="n">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="n">int</span><span class="p">,</span> <span class="n">err</span> <span class="n">error</span><span class="p">)</span> 
 	<span class="n">Write</span><span class="p">(</span><span class="n">buf</span> <span class="p">[]</span> <span class="n">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="n">int</span><span class="p">,</span> <span class="n">err</span> <span class="n">error</span><span class="p">)</span> 
<span class="p">}</span> 
<span class="err">第二个接口：</span>
<span class="k">package</span> <span class="n">two</span> 
<span class="n">type</span> <span class="n">IStream</span> <span class="n">interface</span> <span class="p">{</span> 
 	<span class="n">Write</span><span class="p">(</span><span class="n">buf</span> <span class="p">[]</span> <span class="n">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="n">int</span><span class="p">,</span> <span class="n">err</span> <span class="n">error</span><span class="p">)</span> 
 	<span class="n">Read</span><span class="p">(</span><span class="n">buf</span> <span class="p">[]</span> <span class="n">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="n">int</span><span class="p">,</span> <span class="n">err</span> <span class="n">error</span><span class="p">)</span> 
<span class="p">}</span> 
</code></pre></div></div>
<p>这里我们定义了两个接口，一个叫one.ReadWriter，一个叫two.IStream，两者都定义
了Read()和Write()方法，只是定义的次序相反。one.ReadWriter先定义了Read()再定义
Write()，而two.IStream反之。
在Go语言中，这两个接口实际上并无区别，因为：</p>
<ul>
  <li>任何实现了one.ReadWriter接口的类，均实现了two.IStream；</li>
  <li>任何one.ReadWriter接口对象可赋值给two.IStream，反之亦然；</li>
  <li>在任何地方使用one.ReadWriter接口，与使用two.IStream并无差异。<br />
所以在Go语言中，为了引用另一个包中的接口而导入这个包的做法是不被推荐的。因为多
引用一个外部的包，就意味着更多的耦合。
除了OOP外，近年出现了一些小众的编程哲学，Go语言对这些思想亦有所吸收。例如，Go
语言接受了函数式编程的一些想法，支持匿名函数与闭包。再如，Go语言接受了以Erlang语言为
代表的面向消息编程思想，支持goroutine和通道，并推荐使用消息而不是共享内存来进行并发编
程。总体来说，Go语言是一个非常现代化的语言，精小但非常强大。</li>
</ul>

<h2 id="go语言特性">Go语言特性</h2>
<p>Go语言作为一门全新的静态类型开发语言，与当前的开发语言相比具备众多令人兴奋不已
的新特性。</p>

<h3 id="自动垃圾回收">自动垃圾回收</h3>
<p>我们可以先看下不支持垃圾回收的语言的资源管理方式，以下为一小段C语言代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> 
<span class="p">{</span> 
 	<span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span> 
 	<span class="p">...</span> <span class="c1">// 对p指向的内存块进行赋值
</span> 	<span class="n">func1</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// 使用内存指针
</span> 	<span class="n">delete</span><span class="p">[]</span> <span class="n">p</span><span class="p">;</span> 
<span class="p">}</span> 
</code></pre></div></div>
<p>各种非预期的原因，比如由于开发者的疏忽导致最后的delete语句没有被调用，都会引发经典而恼人的内存泄露问题。<br />
假如该函数被调用得非常频繁，那么我们观察该进程执行时，会发现该进程所占用的内存会一直疯长，直至占用所有系统内存并导致程序崩溃，而如果泄露的是系统资源的话，那么后果还会更加严重，最终很有可能导致系统崩溃。</p>

<p>如果使用Go语言实现，我们就完全不用考虑何时需要释放之前分配的内存的问题，系统会自动帮我们判断，并在合适的时候（比如CPU相对空闲的时候）进行自动垃圾收集工作。</p>

<h3 id="更丰富的内置类型">更丰富的内置类型</h3>
<ul>
  <li>支持几乎所有语言都支持的简单内置类型（比如整型和浮点型等）</li>
  <li>Go语言也内置了一些比较新的语言中内置的高级类型，比如C#和Java中的数组和字符串。</li>
  <li>除此之外，Go语言还内置了一个对于其他静态类型语言通常用库方式支持的字典类型（map）。</li>
  <li>另外有一个新增的数据类型：数组切片（Slice）。我们可以认为数组切片是一种可动态增长的数组。</li>
</ul>

<p>这几种数据结构基本上覆盖了绝大部分的应用场景。</p>

<h3 id="函数多返回值">函数多返回值</h3>
<p>目前的主流语言中除Python外基本都不支持函数的多返回值功能，不是没有这类需求，可能是语言设计者没有想好该如何提供这个功能，或者认为这个功能会影响语言的美感。</p>

<p>Go语言革命性地在静态开发语言阵营中率先提供了多返回值功能。<br />
这个特性让开发者可以从原来用各种比较别扭的方式返回多个值的痛苦中解脱出来，既不用再区分参数列表中哪几个用于输入，哪几个用于输出，也不用再只为了返回多个值而专门定义一个数据结构。</p>

<p>例如：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">getName</span><span class="p">()(</span><span class="n">firstName</span><span class="p">,</span><span class="x"> </span><span class="n">middleName</span><span class="p">,</span><span class="x"> </span><span class="n">lastName</span><span class="p">,</span><span class="x"> </span><span class="n">nickName</span><span class="x"> </span><span class="kt">string</span><span class="p">){</span><span class="x"> 
	</span><span class="k">return</span><span class="x"> </span><span class="s">"May"</span><span class="p">,</span><span class="x"> </span><span class="s">"M"</span><span class="p">,</span><span class="x"> </span><span class="s">"Chen"</span><span class="p">,</span><span class="x"> </span><span class="s">"Babe"</span><span class="x"> 
</span><span class="p">}</span><span class="x"> 
</span></code></pre></div></div>
<p>因为返回值都已经有名字，因此各个返回值也可以用如下方式来在不同的位置进行赋值，从
而提供了极大的灵活性：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">getName</span><span class="p">()(</span><span class="n">firstName</span><span class="p">,</span><span class="x"> </span><span class="n">middleName</span><span class="p">,</span><span class="x"> </span><span class="n">lastName</span><span class="p">,</span><span class="x"> </span><span class="n">nickName</span><span class="x"> </span><span class="kt">string</span><span class="p">){</span><span class="x"> 
 	</span><span class="n">firstName</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="s">"May"</span><span class="x"> 
 	</span><span class="n">middleName</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="s">"M"</span><span class="x"> 
 	</span><span class="n">lastName</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="s">"Chen"</span><span class="x"> 
 	</span><span class="n">nickName</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="s">"Babe"</span><span class="x"> 
	</span><span class="k">return</span><span class="x"> 
</span><span class="p">}</span><span class="x"> 
</span></code></pre></div></div>
<p>并不是每一个返回值都必须赋值，没有被明确赋值的返回值将保持默认的空值。而函数的调用相比C/C++语言要简化很多：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fn</span><span class="p">,</span><span class="x"> </span><span class="n">mn</span><span class="p">,</span><span class="x"> </span><span class="n">ln</span><span class="p">,</span><span class="x"> </span><span class="n">nn</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">getName</span><span class="p">()</span><span class="x"> 
</span></code></pre></div></div>

<p>如果开发者只对该函数其中的某几个返回值感兴趣的话，也可以直接用下划线作为占位符来
忽略其他不关心的返回值。下面的调用表示调用者只希望接收lastName的值，这样可以避免声
明完全没用的变量：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">lastName</span><span class="p">,</span><span class="x"> </span><span class="n">_</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">getName</span><span class="p">()</span><span class="x">
</span></code></pre></div></div>

<h3 id="错误处理">错误处理</h3>
<p>Go语言引入了3个关键字用于标准的错误处理流程，这3个关键字分别为defer、panic和recover。</p>

<p>整体上而言与C++和Java等语言中的异常捕获机制相比，Go语言的错误处理机制可以大量减少代码量，让开发者也无需仅仅为了程序安全性而添加大量一层套一层的try-catch语句，这对于代码的阅读者和维护者来说也是一件很好的事情。</p>

<h3 id="匿名函数和闭包">匿名函数和闭包</h3>
<p>Go语言支持常规的匿名函数和闭包，比如下列代码就定义了一个名为f的匿名函数，开发者可以随意对该匿名函数变量进行传递和调用：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="x"> </span><span class="n">y</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="kt">int</span><span class="x"> </span><span class="p">{</span><span class="x"> 
	</span><span class="k">return</span><span class="x"> </span><span class="n">x</span><span class="x"> </span><span class="o">+</span><span class="x"> </span><span class="n">y</span><span class="x"> 
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<h3 id="类型和接口">类型和接口</h3>
<p>Go语言的类型定义非常接近于C语言中的结构（struct），甚至直接沿用了struct关键字。相比而言，Go语言并没有直接沿袭C++和Java的传统去设计一个超级复杂的类型系统，不支持继承和重载，而只是支持了最基本的类型组合功能。</p>

<p>巧妙的是，虽然看起来支持的功能过于简洁，细用起来你却会发现，C++和Java使用那些复杂的类型系统实现的功能在Go语言中并不会出现无法表现的情况，这反而让人反思其他语言中引入这些复杂概念的必要性。</p>

<h3 id="并发编程">并发编程</h3>
<p>Go语言引入了goroutine概念，它使得并发编程变得非常简单。通过使用goroutine而不是裸用操作系统的并发机制，以及使用消息传递来共享内存而不是使用共享内存来通信，Go语言让并发编程变得更加轻盈和安全。</p>

<p>通过在函数调用前使用关键字go，我们即可让该函数以goroutine方式执行。goroutine是一种比线程更加轻盈、更省资源的协程。Go语言通过系统的线程来多路派遣这些函数的执行，使得每个用go关键字执行的函数可以运行成为一个单位协程。当一个协程阻塞的时候，调度器就会自动把其他协程安排到另外的线程中去执行，从而实现了程序无等待并行化运行。而且调度的开销非常小，一颗CPU调度的规模不下于每秒百万次，这使得我们能够创建大量的goroutine，从而可以很轻松地编写高并发程序，达到我们想要的目的。</p>

<p>下面我们用一个简单的例子来演示goroutine和channel的使用方式。这是一个并行计算的例子，由两个goroutine进行并行的累加计算，待这两个计算过程都完成后打印计算结果：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x"> 

</span><span class="k">import</span><span class="x"> </span><span class="s">"fmt"</span><span class="x"> 

</span><span class="k">func</span><span class="x"> </span><span class="n">sum</span><span class="p">(</span><span class="n">values</span><span class="x"> </span><span class="p">[]</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="n">resultChan</span><span class="x"> </span><span class="k">chan</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x"> 
	</span><span class="n">sum</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="x"> 
	</span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">value</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">values</span><span class="x"> </span><span class="p">{</span><span class="x"> 
		</span><span class="n">sum</span><span class="x"> </span><span class="o">+=</span><span class="x"> </span><span class="n">value</span><span class="x"> 
	</span><span class="p">}</span><span class="x"> 
	</span><span class="n">resultChan</span><span class="x"> </span><span class="o">&lt;-</span><span class="x"> </span><span class="n">sum</span><span class="x"> </span><span class="c">// 将计算结果发送到channel中</span><span class="x">
</span><span class="p">}</span><span class="x"> 

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x"> 
	</span><span class="n">values</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="p">[]</span><span class="x"> </span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span><span class="x"> </span><span class="m">2</span><span class="p">,</span><span class="x"> </span><span class="m">3</span><span class="p">,</span><span class="x"> </span><span class="m">4</span><span class="p">,</span><span class="x"> </span><span class="m">5</span><span class="p">,</span><span class="x"> </span><span class="m">6</span><span class="p">,</span><span class="x"> </span><span class="m">7</span><span class="p">,</span><span class="x"> </span><span class="m">8</span><span class="p">,</span><span class="x"> </span><span class="m">9</span><span class="p">,</span><span class="x"> </span><span class="m">10</span><span class="p">}</span><span class="x"> 
	</span><span class="n">resultChan</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="m">2</span><span class="p">)</span><span class="x"> 
	</span><span class="k">go</span><span class="x"> </span><span class="n">sum</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="o">:</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">/</span><span class="m">2</span><span class="p">],</span><span class="x"> </span><span class="n">resultChan</span><span class="p">)</span><span class="x"> 
	</span><span class="k">go</span><span class="x"> </span><span class="n">sum</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">/</span><span class="m">2</span><span class="o">:</span><span class="p">],</span><span class="x"> </span><span class="n">resultChan</span><span class="p">)</span><span class="x"> 
 	</span><span class="n">sum1</span><span class="p">,</span><span class="x"> </span><span class="n">sum2</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="o">&lt;-</span><span class="n">resultChan</span><span class="p">,</span><span class="x"> </span><span class="o">&lt;-</span><span class="n">resultChan</span><span class="x"> </span><span class="c">// 接收结果</span><span class="x">
 	</span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Result:"</span><span class="p">,</span><span class="x"> </span><span class="n">sum1</span><span class="p">,</span><span class="x"> </span><span class="n">sum2</span><span class="p">,</span><span class="x"> </span><span class="n">sum1</span><span class="x"> </span><span class="o">+</span><span class="x"> </span><span class="n">sum2</span><span class="p">)</span><span class="x"> 
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<h3 id="反射">反射</h3>
<p>反射（reflection）是在Java语言出现后迅速流行起来的一种概念。通过反射，你可以获取对象类型的详细信息，并可动态操作对象。反射是把双刃剑，功能强大但代码可读性并不理想。若非必要，我们并不推荐使用反射。</p>

<p>Go语言的反射实现了反射的大部分功能，但没有像Java语言那样内置类型工厂，故而无法做到像Java那样通过类型字符串创建对象实例。在Java中，你可以读取配置并根据类型名称创建对应的类型，这是一种常见的编程手法，但在Go语言中这并不被推荐。</p>

<h3 id="语言交互性">语言交互性</h3>
<p>由于Go语言与C语言之间的天生联系，Go语言的设计者们自然不会忽略如何重用现有C模块的这个问题，这个功能直接被命名为Cgo。Cgo既是语言特性，同时也是一个工具的名称。</p>

<p>在Go代码中，可以按Cgo的特定语法混合编写C语言代码，然后Cgo工具可以将这些混合的C代码提取并生成对于C功能的调用包装代码。开发者基本上可以完全忽略这个Go语言和C语言的边界是如何跨越的。</p>

<p>例如：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x"> 

</span><span class="c">/* 
#include &lt;stdio.h&gt; 
*/</span><span class="x"> 
</span><span class="k">import</span><span class="x"> </span><span class="s">"C"</span><span class="x"> 
</span><span class="k">import</span><span class="x"> </span><span class="s">"unsafe"</span><span class="x"> 

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x"> 
 	</span><span class="n">cstr</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">C</span><span class="o">.</span><span class="n">CString</span><span class="p">(</span><span class="s">"Hello, world"</span><span class="p">)</span><span class="x"> 
 	</span><span class="n">C</span><span class="o">.</span><span class="n">puts</span><span class="p">(</span><span class="n">cstr</span><span class="p">)</span><span class="x"> 
 	</span><span class="n">C</span><span class="o">.</span><span class="n">free</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">cstr</span><span class="p">))</span><span class="x"> 
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<h2 id="常用标准库">常用标准库</h2>
<p>Go标准库可以大致按其中库的功能进行以下分类，这个分类比较简单，不求准确，但求能够帮助开发者根据自己模糊的需求更快找到自己需要的包。</p>

<ul>
  <li>输入输出。
    <ul>
      <li>这个分类包括二进制以及文本格式在屏幕、键盘、文件以及其他设备上的输入输出等，比如二进制文件的读写。对应于此分类的包有bufio、fmt、io、log和flag等，其中flag用于处理命令行参数。</li>
    </ul>
  </li>
  <li>文本处理。
    <ul>
      <li>这个分类包括字符串和文本内容的处理，比如字符编码转换等。对应于此分类的包有encoding、bytes、strings、strconv、text、mime、unicode、regexp、index和path等。其中path用于处理路径字符串。</li>
    </ul>
  </li>
  <li>网络。
    <ul>
      <li>这个分类包括开发网络程序所需要的包，比如Socket编程和网站开发等。对应于此分类的包有：net、http和expvar等。</li>
    </ul>
  </li>
  <li>系统。
    <ul>
      <li>这个分类包含对系统功能的封装，比如对操作系统的交互以及原子性操作等。对应于此分类的包有os、syscall、sync、time和unsafe等。</li>
    </ul>
  </li>
  <li>数据结构与算法。
    <ul>
      <li>对应于此分类的包有math、sort、container、crypto、hash、archive、compress和image等。因为image包里提供的图像编解码都是算法，所以也归入此类。</li>
    </ul>
  </li>
  <li>运行时。
    <ul>
      <li>对应于此分类的包有：runtime、reflect和go等。</li>
    </ul>
  </li>
</ul>

<h2 id="最后">最后</h2>
<p>这本书还给我们深入讲解了很多有意思的东西，只有自己用心投入去阅读和享受才能真的有所收获，其中还剖析了音乐播放器、聊天系统、网页相册等实际项目例子&amp;核心源代码，总的来说挺不错的，有兴趣的童鞋尽管认真地去翻阅、去学习、去尝试吧。</p>

<p>最后，让我们引用作者的话来结束本篇鉴赏吧。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>在十余年的技术生涯中，我接触过、使用过、喜爱过不同的编程语言，但总体而言，Go语
言的出现是最让我兴奋的事情。

我个人对未来10年编程语言排行榜的趋势判断如下：
❤ Java语言的份额继续下滑，并最终被C和Go语言超越；
❤ C语言将长居编程榜第二的位置，并有望在Go取代Java前重获语言榜第一的宝座；
❤ Go语言最终会取代Java，居于编程榜之首。

由七牛云存储团队编著的这本书将尽可能展现出Go语言的迷人魅力。希望本书能够让更多
人理解这门语言，热爱这门语言，让这门优秀的语言能够落到实处，把程序员从以往繁杂的语言
细节中解放出来，集中精力开发更加优秀的系统软件。

许式伟
2012年3月7日
</code></pre></div></div>

<h2 id="关于我">关于我</h2>
<p>name: yison.li<br />
blog: <a href="http://yyeer.com">http://yyeer.com</a><br />
github: <a href="https://github.com/yisonli">https://github.com/yisonli</a></p>

<p><img src="http://yyeer.com/assets/img/YisonWechat.png" alt="" /></p>
  
	</div>
	<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <!--
  <%- list_categories(item.categories, {
      show_count: false,
      class: 'article-category',
      style: 'none',
      separator: '►'
  }) %>
  -->
  
  <a class="article-category-link" href="/categories/#读书">读书</a>
  
  <a class="article-category-link" href="/categories/#编程">编程</a>
  
</div>


  <div class="article-tags">
  <!--
  <% var tags = [];
    item.tags.forEach(function(tag){
      tags.push('<a href="' + config.root + tag.path + '">' + tag.name + '</a>');
    }); %>-->
  <span></span> <!--<%- tags.join('') %>-->
  
  
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://localhost:4000/%E8%AF%BB%E4%B9%A6/%E7%BC%96%E7%A8%8B/2020/12/03/Go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B-%E9%89%B4%E8%B5%8F/" data-title="《go语言编程》☞鉴赏 | Yison's Blog" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>
   
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/%E7%BC%96%E7%A8%8B/2020/05/09/Go%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" title="Go依赖管理工具">
  <strong>上一篇：</strong><br/>
  <span>
  Go依赖管理工具</span>
</a>
</div>


<div class="next">
<a href="/%E7%BC%96%E7%A8%8B/2021/07/17/GRPC%E4%B8%80%E7%82%B9%E9%80%9A/"  title="Grpc一点通">
 <strong>下一篇：</strong><br/> 
 <span>Grpc一点通
</span>
</a>
</div>

</nav>

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="/assets/js/md5.js"></script>
<div id="gitalk-container" style="padding:0 4%;"></div>
<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '6e26f3ed90af4176bf66',
    clientSecret: 'e4c758e742cf68cec349df440464d743a619b1f9',
    repo: 'comment',
    owner: 'yisonli',
    admin: ['yisonli'],
    id: hex_md5(location.pathname),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>


</div>  

      
      
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside toc-content">
 
 <!--<%- toc(item.content) %>-->
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/#版本控制" title="版本控制">版本控制<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/#编程" title="编程">编程<sup>23</sup></a></li>
		  
		
		  
			<li><a href="/categories/#操作系统" title="操作系统">操作系统<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/#数据库" title="数据库">数据库<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/#读书" title="读书">读书<sup>7</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/#Git" title="Git">Git<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#PHP" title="PHP">PHP<sup>12</sup></a></li>
			
		
			
				<li><a href="/tags/#Nginx" title="Nginx">Nginx<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Linux" title="Linux">Linux<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/#Mysql" title="Mysql">Mysql<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#云" title="云">云<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#前端" title="前端">前端<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#管理" title="管理">管理<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Laravel" title="Laravel">Laravel<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/#大数据" title="大数据">大数据<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#C" title="C">C<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Docker" title="Docker">Docker<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#Cache" title="Cache">Cache<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/#Go" title="Go">Go<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/#GRPC" title="GRPC">GRPC<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/#微服务" title="微服务">微服务<sup>3</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            <a href="https://yisonli.cnblogs.com" target="_blank" title="Yisonli博客园">Yisonli博客园</a>
          </li>
        
    </ul>
</div>

  

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>



</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I'm Yison Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
	<!--
			<%  Array.prototype.S=String.fromCharCode(2);
			  Array.prototype.in_array=function(e){
    			var r=new RegExp(this.S+e+this.S);
    			return (r.test(this.S+this.join(this.S)+this.S));
				};
				var cc = new Array('by','by-nc','by-nc-nd','by-nc-sa','by-nd','by-sa','zero'); %>
		<% if (cc.in_array(theme.creative_commons) ) { %>
				<div class="cc-license">
          <a href="http://creativecommons.org/licenses/<%= theme.creative_commons %>/4.0" class="cc-opacity" target="_blank">
            <img src="<%- config.root %>img/cc-<%= theme.creative_commons %>.svg" alt="Creative Commons" />
          </a>
        </div>
    <% } %>
				-->

		<p class="copyright">
		Powered by <a href="http://jekyllrb.com" target="_blank" title="jekyll">jekyll</a> and Theme by <a href="https://github.com/simpleyyt/jekyll-jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="about" target="_blank" title="yison">yison</a>
		
		
		</p>
</div>
</footer>
    <script src="/assets/js/jquery-2.0.3.min.js"></script>
<script src="/assets/js/jquery.imagesloaded.min.js"></script>
<script src="/assets/js/gallery.js"></script>
<script src="/assets/js/jquery.qrcode-0.12.0.min.js"></script>
<script src="/assets/js/toc.js"></script>

<script type="text/javascript">
$(document).ready(function(){
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });

  

  $(window).resize(function(){
    getSize();
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
      
    }
  });
});
</script>




<script type="text/javascript">
$(document).ready(function(){
  $('#toc.toc-aside').toc({
    title: "文章目录",
    showEffect: "none"
  });
  $('#toc.toc-article').toc({
    title: "文章目录",
    showEffect: "show",
    showSpeed: 0
  });
});
</script>



<script type="text/javascript">
$(document).ready(function(){
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>



<style type="text/css">
  .article-share-qq:before { content: "\f1d6"; }
  .article-share-qq:hover { background: #00aced; text-shadow: 0 1px #008abe }
  .bdshare-button-style1-16 {}
</style>
<script type="text/javascript">
$(document).ready(function(){
  var $this = $('.share'),
      url = location.href,//$this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#nothing"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://qr.liantu.com/api.php?text=' + encodedUrl + '"/></div>',
  // '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  // '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=' + encodedUrl + '&sharesource=qzone&title=' + title + '" class="article-share-qq" target="_blank" title="QQ空间"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
/*
  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      //$('.hoverqrcode').hide();
  });
  */
});
</script>






<!--

-->




<link rel="stylesheet" href="/assets/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/assets/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      if ($(this).hasClass('emoji')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
});
</script>


<!-- Analytics Begin -->



<div style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F3f1c1d7a96a77c3559936efffb01e0cc' type='text/javascript'%3E%3C/script%3E"));
</script>
</div>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/assets/img/scrollup.png"/></a>
	</div>
	<script src="/assets/js/totop.js"></script>


<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>

